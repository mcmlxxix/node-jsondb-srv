{
  "_args": [
    [
      "node-jpath",
      "Z:\\dev\\node\\nodeapps\\json-db-srv"
    ]
  ],
  "_from": "node-jpath@latest",
  "_id": "node-jpath@2.1.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/node-jpath",
  "_npmUser": {
    "email": "webdevsimon@gmail.com",
    "name": "stsvilik"
  },
  "_npmVersion": "1.1.66",
  "_phantomChildren": {},
  "_requested": {
    "name": "node-jpath",
    "raw": "node-jpath",
    "rawSpec": "",
    "scope": null,
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/node-jpath/-/node-jpath-2.1.0.tgz",
  "_shasum": "21872466039bc3969dcb3863ab42671f61ff51b2",
  "_shrinkwrap": null,
  "_spec": "node-jpath",
  "_where": "Z:\\dev\\node\\nodeapps\\json-db-srv",
  "author": {
    "email": "webdevsimon@gmail.com",
    "name": "Simon Tsvilik"
  },
  "bugs": {
    "url": "https://github.com/stsvilik/node-jpath/issues"
  },
  "dependencies": {},
  "description": "jPath: Traversal utility to help you digg deeper into complex objects or arrays of objects",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "21872466039bc3969dcb3863ab42671f61ff51b2",
    "tarball": "http://registry.npmjs.org/node-jpath/-/node-jpath-2.1.0.tgz"
  },
  "homepage": "https://github.com/stsvilik/node-jpath#readme",
  "keywords": [
    "utility",
    "xpath",
    "jpath",
    "traversal",
    "objects"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/stsvilik/node-jpath/blob/master/LICENSE-MIT"
    }
  ],
  "main": "./lib/node-jpath",
  "maintainers": [
    {
      "email": "webdevsimon@gmail.com",
      "name": "stsvilik"
    }
  ],
  "name": "node-jpath",
  "optionalDependencies": {},
  "readme": "node-jPath\n====\nUtility library to help you traverse and filter out data from complex JSON and or Arrays of objects.\nThe strength of this library lies in ability to use XPath-like expressions to retrieve data you need.\n\n#### How is it different from XPath?\n\nBecause we're dealing with javascript, I felt that syntax should inherit some of that syntactical sugar that we're all used to when coding JavaScript\nand that is why the pattern syntax uses dots(.) instead of slashes. One thing that jPath lacks in comparisson with XPath is ability to look for conditions \"anywhere\" within a structure (i.e. //foo), this operation is just too expensive.\n\n#### How does it work?\n\njPath is a recursive scanner that processes each token of your pattern at a time passing the results of the findings back to itself. As it runs conditions to match the values, it tries to match value types on the left and right sides of the equasion (apples to apples, oranges to oranges). Results of the traversal are merged into a single Array.\n\n#### Install\n\n\tnpm install node-jpath\n\n#### Examples\n\n\tvar jsonData = {\n\t\tpeople: [\n\t\t\t{name: \"John\", age:26, gender:\"male\"},\n\t\t\t{name: \"Steve\", age:24, gender:\"male\"},\n\t\t\t{name: \"Susan\", age:22, gender:\"female\"},\n\t\t\t{name: \"Linda\", age:30, gender:\"female\"},\n\t\t\t{name: \"Adam\", age:32, gender:\"male\"}\n\t\t]\n\t};\n\t//We want to get all males younger then 25\n\tvar match = jpath.filter(jsonData, \"people[gender=male && age < 25]\");\n\n\tOutput:\n\t[{name: \"Steve\", age:24, gender:\"male\"}]\n\n\t//Now lets try to get people that have a 5 letter name\n\tvar match = jpath.filter(jsonData, \"people[name.length == 5]\");\n\n\tOutput:\n\t[{name: \"Steve\", age:24, gender:\"male\"},{name: \"Susan\", age:22, gender:\"female\"},{name: \"Linda\", age:30, gender:\"female\"}]\n\n\t//I want to get only names of people as an array of strings\n\tvar match = jpath.filter(jsonData, \"people.name\");\n\n\tOutput:\n\t[\"John\", \"Steve\", \"Susan\", \"Linda\", \"Adam\"]\n\n\t//I need to get people that have gender (in our case all of them will, but in case field is missing this operation is useful)\n\tvar match = jpath.filter(jsonData, \"people[gender != undefined]\");\n\n\n#### Does it support conditions?\n\nJust like XPATH, it does support conditional filtering, where you basically specify what nodes you want to retrieve\nbased on certain condition. Conditional queries work by comparing data members to value you provide inside your\nexpression (it does not do comparing between data members). So for example if you have an array of objects and you want\nto get only those objects where member foo = 1, you would write \"obj[foo == 1]\", more examples later. It supports a\nwide range of evaluations.\n\n- \"==\" | \"=\" - compares data member for equality\n- \"!=\" - compares data member inequality\n- \"<\" - less than\n- \">\" - greater than\n- \"<=\" - less or equal\n- \">=\" - greater or equal\n- \"~=\" - equal ignoring case\n- \"^=\" - starts with\n- \"$=\" - ends with\n- \"*=\" - contains a string anywhere inside (case insensitive)\n- \"?\" - allows you to pass a custom evaluation function (runs in the scope of evaluated object so you can compare against other object members).\n\nDuring the comparing stage, all values are type matched (coerced) to the types of values you're comparing against.\nWhat this means is that you always compare numbers against numbers and not strings, and same goes for every other data\ntype.\n\nIf your value contains a space, you can enclose your value in single or double quotes. (i.e. [foo == 'hello world']) Normally you\ndon't have to do that. If your value contains quotes, you can escape them using double slashes (i.e [foo == 'Bob\\\\\\'s']).\n\n#### What else can it do?\n\nOne thing to note is that there is a special \"*\" selector that references an object itself, so you may use it lets say\nagainst an array of objects (i.e. *[ foo == bah] - will return rows where member foo has value bah). You can also have\n\"deep\" value comparing (i.e. obj[ foo.bah == \"wow\"] ). Now that you can do deep value comparing, you can also check for\nnative properties such as \"length\" (i.e. obj( [ name.length > 3 ]) ). You can also reverse condition for any of the operations by wrapping them in \"!(...)\".\n\n#### Using reserved words to compare\n\nJPath supports the use of 'null' and 'undefined' in conditions.\nSo if you're traversing an array of objects where your object may NOT contain a member you can always write *[foo == undefined].\n\n#### What is not here\n\n- JPath does not support \"select-all\" syntax of XPATH that allowed you to find something anywhere in the XML document. This is too expensive in JavaScript.\n- JPath does not natively supports conditions that compare one data memeber against another, but this can be achieved using \"a ? b\" and the use of \"this\" in the custom comparator.\n\n#### Working with Arrays\n\nWorking with Arrays requires a special character to reference Array itself in the expression, for this we'll use \"\\*\".\n#### Example:\n\tvar people = [\n\t\t{name: \"John\", age:26, gender:\"male\"},\n\t\t{name: \"Steve\", age:24, gender:\"male\"},\n\t\t{name: \"Susan\", age:22, gender:\"female\"},\n\t\t{name: \"Linda\", age:30, gender:\"female\"},\n\t\t{name: \"Adam\", age:32, gender:\"male\"}\n\t];\n\tvar match = jpath.filter(people, \"*[gender==female]\");\n\tOutput:\n\t[{name: \"Susan\", age:22, gender:\"female\"},{name: \"Linda\", age:30, gender:\"female\"}]\n\nAPI\n---\njPath exposes two methods: filter() and select(). select method returns an instance of JPath object that allows you to do alot more then just get results of the pattern match.\n\n### Classes\n\n* JPath\n\t* constructor( json ) - initializes JPath instance\n\t* data - local copy of json object you passed in during init.\n\t* selection - cached result of the selection\n\t* from( json ) - this method allows you to change json source\n\t* first() - returns the first result value\n\t* last() - returns the last result value\n\t* eq( index ) - returns result value by index\n\t* select( pattern [, custom_compare_function ]) - performs recursive search\n\t* and( pattern ) - this method allows combining of multiple search results.\n\t* val() - {Array} returns the final value of selection\n\n### Methods\n\n* select( json, expression [,cust_compare_fn] ) - performs a traversal and returns you an instance of JPath object\n* filter( json, expression [,cust_compare_fn] ) - performs a traversal and returns a value\n\n#### More Examples\n\n1. Using Custom compare logic\n\n        jPath.filter( JSON, \"foo[bar ? test]\", function(left, right) {\n            //left - is the value of the data member bar inside foo\n            //right - would be equal to \"test\"\n            return left + \"blah\" == right; //Cusom validation\n        });\n\n2. Joining multiple filtering results\n\n        jPath.select( JSON, \"foo[bar == 1]\").and( \"foo2[bar == 2]\").val(); //This example adds to the selection a different pattern evaluation\n\n    Example above could also be written like so:\n\n        jPath.select( JSON, \"foo[bar == 1 || bar == 2]\").val();\n\n3. If we want to combine results from different JSON objects, than we would do something like so:\n\n        jPath.select( JSON, \"foo[bar == 1]\").from(JSON2).and( \"foo2[bar == 2]\").val(); //from() sets a different source of data\n\n4. Accessing array elements by index\n\n        jPath.select({myArray:[1,2,3,4,5]}, \"myArray(0)\");\n\n5. Using parenteces to group logic\n\n        jPath.filter(obj, \"*[(a==b || a == c) && c == d]\");\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/stsvilik/node-jpath.git"
  },
  "version": "2.1.0"
}
